#version 440

struct LabelledWorldPoint
{
    vec3 world_position;
    int point_id;
};

struct CameraData
{
    ivec2 resolution;
    float fov;
    vec2 focal_lengths;
    vec3 radial_distortion_coefficients;
    vec2 tangential_distortion_coefficents;
    mat3x3 rotation_matrix;
};

struct Jacobian
{
    mat2x3 f_e;
    mat2x3 f_c;
    mat2x3 f_x;
};

layout(std430, binding = 0) buffer point_positions_ssbo { LabelledWorldPoint point_positions[]; };
layout(std430, binding = 1) buffer camera_positions_ssbo { vec3 camera_positions[]; };
layout(std430, binding = 2) buffer camera_rotations_ssbo { vec3 camera_rotations[]; };
layout(std430, binding = 3) buffer camera_datas_ssbo { CameraData camera_datas[]; };

layout(std430, binding = 5) buffer jacobians_ssbo { Jacobian jacobians[]; };

layout(local_size_x = 1, local_size_y = 1) in;
void main()
{
    CameraData cam_data = camera_datas[gl_GlobalInvocationID.x];
    LabelledWorldPoint point = point_positions[gl_GlobalInvocationID.x];
    vec3 camera_position = camera_positions[gl_GlobalInvocationID.x];

    mat3x3 R = cam_data.rotation_matrix;

    // focal lengths
    float lx = cam_data.focal_lengths.x;
    float ly = cam_data.focal_lengths.y;

    // radial coefficients
    float k1 = cam_data.radial_distortion_coefficients.x;
    float k2 = cam_data.radial_distortion_coefficients.y;
    float k3 = cam_data.radial_distortion_coefficients.z;

    // tangential coefficients
    float p1 = cam_data.tangential_distortion_coefficents.x;
    float p2 = cam_data.tangential_distortion_coefficents.y;

    // projection 3-vector
    vec3 p = R * (point.world_position - camera_position);
    float r_sq = dot(p, p);
    float r_sq_poly = (2 * k1) + (4 * k2 * r_sq) + (6 * k3 * r_sq * r_sq);

    // un-distorted projection position + du/dp
    vec2 u = vec2(lx * p.x, ly * p.y) / p.z;
    mat2x3 u_prime = mat2x3(-lx, 0, 0, -ly, -lx * p.x / p.z, -ly * p.y / p.z) / p.z;


    // camera position component 
    // Un-distorted jacobian
    mat2x3 cam_pos_u = u_prime * R;

    // Radial distortion component
    mat2x3 cam_pos_r = -(cam_pos_u * (r_sq_poly * p * R)) - cam_pos_u;

    // tangential distortion component
    vec2 rho_n = vec2(p1, p2);
    vec2 rho_i = vec2(p2, p1);

    vec2 cam_pos_t_x = ((2 * rho_n * p.y) + (2 * rho_i * p.x) + vec2(4 * p.x, 0));
    vec2 cam_pos_t_y = ((2 * rho_n * p.x) + (2 * rho_i * p.y) + vec2(0, 4 * p.y));
    vec2 cam_pos_t_z = rho_i * p.z;
    mat2x3 cam_pos_t = mat2x3(cam_pos_t_x, cam_pos_t_y, cam_pos_t_z) * R;

    mat2x3 cam_pos_component = cam_pos_u + cam_pos_r + cam_pos_t;


    // Point position (-ve cam pos component because p = R(X-C))
    mat2x3 point_pos_component = -cam_pos_component;


    // camera rotation component (ToDo)
    mat2x3 cam_rot_u = mat2x3(0, 0, 0, 0, 0, 0);
    mat2x3 cam_rot_component = mat2x3(0, 0, 0, 0, 0, 0);


    // Final jacobian
    jacobians[gl_GlobalInvocationID.x] = Jacobian(cam_rot_component, cam_pos_component, point_pos_component);
}