#version 440

struct LabelledWorldPoint
{
    vec3 world_position;
    int point_id;
};

struct CameraData
{
    ivec2 resolution;
    float fov;
    mat3 rotation_matrix;
    
    vec2 focal_lengths;
    vec3 radial_distortion_coefficients;
    vec2 tangential_distortion_coefficents;
};

struct CameraRotationDerivatives
{
    mat3 rotation_matrix_by_dx;
    mat3 rotation_matrix_by_dy;
    mat3 rotation_matrix_by_dz;
};

struct Jacobian
{
    mat3x2 f_e;
    mat3x2 f_c;
    mat3x2 f_x;
};

float sq(float x) { return x * x; }

layout(std430, binding = 0) buffer point_positions_ssbo { LabelledWorldPoint point_positions[]; };
layout(std430, binding = 1) buffer camera_positions_ssbo { vec3 camera_positions[]; };
layout(std430, binding = 2) buffer camera_rotations_ssbo { vec3 camera_rotations[]; };
layout(std430, binding = 3) buffer camera_datas_ssbo { CameraData camera_datas[]; };
layout(std430, binding = 4) buffer camera_rotation_derivatives_ssbo { CameraRotationDerivatives camera_rotation_derivatives[]; };

layout(std430, binding = 5) buffer jacobians_ssbo { Jacobian jacobians[]; };

layout(local_size_x = 1, local_size_y = 1) in;
void main()
{
    // 0. Commonly Used Values
    CameraData cam_data = camera_datas[gl_GlobalInvocationID.x];
    LabelledWorldPoint point = point_positions[gl_GlobalInvocationID.x];
    vec3 camera_position = camera_positions[gl_GlobalInvocationID.x];

        // shorter name for rotation matrix
    mat3 R = cam_data.rotation_matrix;


        // focal lengths
    float lx = cam_data.focal_lengths.x, lx_sq = sq(lx);
    float ly = cam_data.focal_lengths.y, ly_sq = sq(ly);

        // radial coefficients
    float k1 = cam_data.radial_distortion_coefficients.x;
    float k2 = cam_data.radial_distortion_coefficients.y;
    float k3 = cam_data.radial_distortion_coefficients.z;

        // tangential coefficients
    vec2 t = cam_data.tangential_distortion_coefficents.xy;
    vec2 t_i = cam_data.tangential_distortion_coefficents.yx;
    float t1 = t.x;
    float t2 = t.y;

        // projection 3-vector
    vec3 r_X_C = point.world_position - camera_position;
    vec3 p = R * r_X_C;


        // un-distorted projection position & du/dp
    vec2 u = vec2(lx * p.x, ly * p.y) / p.z;
    mat3x2 d_u_by_d_p = mat3x2(-lx, 0, 0, -ly, -lx * p.x / p.z, -ly * p.y / p.z) / p.z;

        // radial distance from centre of screen of the un-distorted projected point, powers of it, & d(r^2)/dp
    float r_sq = dot(u, u);
    float r_qd = sq(r_sq);
    float r_sx = sq(r_sq) * r_sq;
    vec3 d_r_sq_by_d_p = (-2 / p.z) * vec3(lx_sq * p.x, ly_sq * p.y, -((lx_sq * sq(p.x)) + (ly_sq * sq(p.y))) / p.z);

        // common polynomial in r_sq & derivative d(r_poly) / d(r^2)
    float r_poly = (2 * k1 * r_sq) + (4 * k2 * r_qd) + (6 * k3 * r_sx);
    float d_r_poly_by_d_r_sq = (k1) + (2 * k2 * r_sq) + (3 * k3 * r_qd);



    // 1. Camera Position Component 
        // 1.0) Camera Position Specific Values

            // dp/dC = -R
    mat3 d_p_by_d_C = -R;

            // dU/dC = dU/dp * dp/dC
    mat3x2 d_u_by_d_C = d_u_by_d_p * d_p_by_d_C;

            // d(r^2)/dC
    vec3 d_r_sq_by_d_C = d_r_sq_by_d_p * d_p_by_d_C;


        // 1.1) Un-distorted Component
            // dU/dC = dU/dp * dp/dC
    mat3x2 cam_pos_u = d_u_by_d_C;


        // 1.2) Radial Distortion Component
            // dUr/dC 
            //      = d/dC {U * r_poly} 
            //      = (dU/dC * r_poly) + (U * d(r_poly)/dC)  (Product Rule)
            //      = (dU/dC * r_poly) + (U * d(r_poly)/d(r^2) * d(r^2)/dC)
            //      = cam_pos_r_1 + cam_pos_r_2

            // dU/dC * r_poly
    mat3x2 cam_pos_r_1 = (d_u_by_d_C * r_poly);

            // U * d(r^2)/dC * d(r_poly)/d(r^2)
    mat3x2 cam_pos_r_2 = outerProduct(u, d_r_sq_by_d_C) * d_r_poly_by_d_r_sq;

            // dUr/dC
    mat3x2 cam_pos_r = cam_pos_r_1 + cam_pos_r_2;


        // 1.3) Tangential Distortion Component
            // dUt/dC
            //      = d/dC {[[2*t1*ux*uy + t2*r^2 + 2*t2*ux^2)], [2*t2*ux*uy + t1*r^2 + 2*t1*uy^2]]}
            //      = d/dC {[[2*t1*ux*uy], [2*t2*ux*uy]] + [[t2*r^2], [t1*r^2]] + [[2*t2*ux^2], [2*t1*uy^2]]}

            // d/dC {[[2*t1*ux*uy], [2*t2*ux*uy]]}
    vec3 cam_pos_t_1_1 = (lx * ly / sq(p.z)) * vec3(p.y, p.x, -p.x * p.y / p.z);
    mat3x2 cam_pos_t_1 = 2 * outerProduct(t, cam_pos_t_1_1) * d_p_by_d_C;

            // d/dC {[[t2*r^2], [t1*r^2]]}
    mat3x2 cam_pos_t_2 = outerProduct(t_i, d_r_sq_by_d_C);

            // d/dC {[[2*t2*ux^2], [2*t1*uy^2]]}
    mat3x2 cam_pos_t_3_1 = (1 / sq(p.z)) * mat3x2(2 * t2 * lx_sq * p.x, 0, 
        0, 2 * t1 * ly_sq * p.y, 
        -3 * t2 * lx_sq * sq(p.x) / p.z, -3 * t1 * ly_sq * sq(p.y) / p.z);
    mat3x2 cam_pos_t_3 = 2 * cam_pos_t_3_1 * d_p_by_d_C;

            // dUt/dC
    mat3x2 cam_pos_t = cam_pos_t_1 + cam_pos_t_2 + cam_pos_t_3;


        // 1.4) Combining The Components
    mat3x2 cam_pos_component = cam_pos_u + cam_pos_r + cam_pos_t;



    // 2. Point Position Component
        // dU/dX = dU/dp * dp/dX
        // dp/dX = d/dX {R*(X-C)} = R 
        // Note that dp/dC = -R 
        //      => dp/dX = -dp/dC
        // Hence: dU/dX = dU/dp * (-dp/dC) = -dU/dC
    mat3x2 point_pos_component = -cam_pos_component;



    // 3. Point Rotation Component
        // 1.0) Camera Rotation Specific Values

            // dR/dE = (dR/dE_x * dE_x/dE) + (dR/dE_y * dE_y/dE) + (dR/dE_z * dE_z/dE)
            // dE_i/dE = vec(v_i1, v_i2, ..., v_ij, ..., v_in) where v_ij = Kronecker(i, j) 
            //  therefore, dE_x/dE = (1, 0, 0), dE_y/dE = (0, 1, 0), dE_z/dE = (0, 0, 1)
    mat3 d_R_by_d_E_x = camera_rotation_derivatives[gl_GlobalInvocationID.x].rotation_matrix_by_dx;
    mat3 d_R_by_d_E_y = camera_rotation_derivatives[gl_GlobalInvocationID.x].rotation_matrix_by_dy;
    mat3 d_R_by_d_E_z = camera_rotation_derivatives[gl_GlobalInvocationID.x].rotation_matrix_by_dz;

            // dp/dR = d/dR {R(X-C)} = X-C
    vec3 d_p_by_d_R = r_X_C;
    
            // dp/dE = [d/dEx, d/dEy, d/dEz](p)
            // dp/dEx = dp/dR * dR/dEx
    vec3 d_p_by_d_E_x = d_p_by_d_R * d_R_by_d_E_x;
    vec3 d_p_by_d_E_y = d_p_by_d_R * d_R_by_d_E_y;
    vec3 d_p_by_d_E_z = d_p_by_d_R * d_R_by_d_E_z;
    mat3 d_p_by_d_E = mat3(d_p_by_d_E_x, d_p_by_d_E_y, d_p_by_d_E_z);

            // dU/dE = dU/dp * dp/dE
    mat3x2 d_u_by_d_E = d_u_by_d_p * d_p_by_d_E;

            // d(r^2)/dE
    vec3 d_r_sq_by_d_E = d_r_sq_by_d_p * d_p_by_d_E;


        // 1.1) Un-distorted Component
            // dU/dE = dU/dp * dp/dE
    mat3x2 cam_rot_u = d_u_by_d_E;


        // 1.2) Radial Distortion Component
            // dUr/dE 
            //      = d/dE {U * r_poly} 
            //      = (dU/dE * r_poly) + (U * d(r_poly)/dE)  (Product Rule)
            //      = (dU/dE * r_poly) + (U * d(r_poly)/d(r^2) * d(r^2)/dE)
            //      = cam_rot_r_1 + cam_rot_r_2

            // dU/dE * r_poly
    mat3x2 cam_rot_r_1 = (d_u_by_d_E * r_poly);

            // U * d(r^2)/dE * d(r_poly)/d(r^2)
    mat3x2 cam_rot_r_2 = outerProduct(u, d_r_sq_by_d_E) * d_r_poly_by_d_r_sq;

            // dUr/dE
    mat3x2 cam_rot_r = cam_rot_r_1 + cam_rot_r_2;


        // 1.3) Tangential Distortion Component
            // dUt/dE
            //      = d/dE {[[2*t1*ux*uy + t2*r^2 + 2*t2*ux^2)], [2*t2*ux*uy + t1*r^2 + 2*t1*uy^2]]}
            //      = d/dE {[[2*t1*ux*uy], [2*t2*ux*uy]] + [[t2*r^2], [t1*r^2]] + [[2*t2*ux^2], [2*t1*uy^2]]}

            // d/dE {[[2*t1*ux*uy], [2*t2*ux*uy]]}
    vec3 cam_rot_t_1_1 = (lx * ly / sq(p.z)) * vec3(p.y, p.x, -p.x * p.y / p.z);
    mat3x2 cam_rot_t_1 = 2 * outerProduct(t, cam_rot_t_1_1) * d_p_by_d_E;

            // d/dE {[[t2*r^2], [t1*r^2]]}
    mat3x2 cam_rot_t_2 = outerProduct(t_i, d_r_sq_by_d_E);

            // d/dE {[[2*t2*ux^2], [2*t1*uy^2]]}
    mat3x2 cam_rot_t_3_1 = (1 / sq(p.z)) * mat3x2(2 * t2 * lx_sq * p.x, 0, 
        0, 2 * t1 * ly_sq * p.y, 
        -3 * t2 * lx_sq * sq(p.x) / p.z, -3 * t1 * ly_sq * sq(p.y) / p.z);
    mat3x2 cam_rot_t_3 = 2 * cam_rot_t_3_1 * d_p_by_d_E;

            // dUt/dE
    mat3x2 cam_rot_t = cam_rot_t_1 + cam_rot_t_2 + cam_rot_t_3;


        // 1.4) Combining The Components
    mat3x2 cam_rot_component = cam_rot_u + cam_rot_r + cam_rot_t;



    // 4. Full jacobian
    jacobians[gl_GlobalInvocationID.x] = Jacobian(cam_rot_component, cam_pos_component, point_pos_component);
}