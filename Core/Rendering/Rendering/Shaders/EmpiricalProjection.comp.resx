#version 430

struct Point
{
    vec4 world_position;
    vec2 screen_position;
    ivec2 pixel_position;
    bool is_visible;
};

layout(std430, binding = 0) buffer points_ssbo { Point points[]; };

uniform vec2 u_focal_lengths;
uniform vec3 u_radial_distortion;
uniform vec2 u_tangential_distortion;

uniform mat3 u_camera_rotation;
uniform vec3 u_camera_position;

uniform ivec2 u_output_resolution;


layout(local_size_x = 1, local_size_y = 1) in;
void main()
{
    Point point = points[gl_GlobalInvocationID.x];

    // Position relative to camera
    vec3 pos_c = u_camera_rotation * (point.world_position.xyz - u_camera_position);

    if (pos_c.z > 0)
    {
        // Project onto camera plane
        vec2 pos_c_p = vec2(u_focal_lengths.x * pos_c.x, u_focal_lengths.y * pos_c.y) / pos_c.z;

        // Distortions
        // Radial
        float rad_dist_sq = dot(pos_c_p, pos_c_p);          // ^2
        float rad_dist_qd = rad_dist_sq * rad_dist_sq;      // ^4
        float rad_dist_sx = rad_dist_qd * rad_dist_sq;      // ^6

        float r_distortion = (u_radial_distortion.x * rad_dist_sq) + 
                            (u_radial_distortion.y * rad_dist_qd) +
                            (u_radial_distortion.z * rad_dist_sx);
        vec2 r_distortion_offset = r_distortion * pos_c_p;

        // Tangential
        vec2 t_distortion_1 = 2 * pos_c_p.x * pos_c_p.y * u_tangential_distortion.yx;
        vec2 t_distortion_2 = u_tangential_distortion.xy * rad_dist_sq;
        vec2 t_distortion_3 = 2 * vec2(u_tangential_distortion.x * pos_c_p.x * pos_c_p.x, u_tangential_distortion.y * pos_c_p.y * pos_c_p.y);

        vec2 t_distortion = t_distortion_1 + t_distortion_2 + t_distortion_3;

        // Apply distortions
        vec2 pos_c_corrected = pos_c_p + r_distortion_offset + t_distortion;

        // Calculate screen positions
        point.is_visible = true;
        point.screen_position = pos_c_corrected;
        point.pixel_position = ivec2(int((pos_c_corrected.x + 0.5) * u_output_resolution.x), int((pos_c_corrected.y + 0.5) * u_output_resolution.y));
        //point.pixel_position = ivec2(point.world_position.x * u_output_resolution.x / 2, point.world_position.y * u_output_resolution.y / 2);
    }
    else
    {
        point.is_visible = false;
    }

    points[gl_GlobalInvocationID.x] = point;
}